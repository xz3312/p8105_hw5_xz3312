---
title: "p8105_hw5_xz3312"
author: "Eric Zhang"
date: "2025-11-11"
output: github_document
---

```{r packages}
library(tidyverse)
library(ggplot2)
library(viridis)
library(broom)
set.seed(1234)

theme_set(
  theme_minimal() +
    theme(
      legend.position = "bottom",
      plot.title = element_text(face = "bold", size = 14),
      axis.text = element_text(size = 11),
      axis.title = element_text(size = 12)
    )
)

options(
  ggplot2.continuous.colour = "viridis",
  ggplot2.continuous.fill  = "viridis"
)

scale_colour_discrete <- scale_colour_viridis_d
scale_fill_discrete   <- scale_fill_viridis_d
```

# Problem 1

### Suppose you put ð‘› people in a room, and want to know the probability that at least two people share a birthday. For simplicity, weâ€™ll assume there are no leap years (i.e. there are only 365 days) and that birthdays are uniformly distributed over the year (which is actually not the case). Write a function that, for a fixed group size, randomly draws â€œbirthdaysâ€ for each person; checks whether there are duplicate birthdays in the group; and returns TRUE or FALSE based on the result.
```{r}
# To simulate this, I define a function called birthday_simulation. For a chosen group size, the function randomly assigns each person a birthday by sampling from the integers 1 through 365 with replacement. If at least one birthday is shared the function returns TRUE.

birthday_simulation <- function(n) {
  birthdays <- sample(x = 1:365, size = n, replace = TRUE)
  return(length(birthdays) != length(unique(birthdays)))
}
```


### Run this function 10000 times for each group size between 2 and 50. For each group size, compute the probability that at least two people in the group will share a birthday by averaging across the 10000 simulation runs. Make a plot showing the probability as a function of group size, and comment on your results.
```{r}
estimate_shared_bday <- function(n, B = 10000) {
  hits <- vapply(
    1:B,
    function(i) any(duplicated(sample.int(365, n, replace = TRUE))),
    logical(1)
  )
  mean(hits)
}

sizes <- 2:50
probability_table <- tibble(
  group_size = sizes,
  shared_birthday_prob = vapply(sizes, estimate_shared_bday, numeric(1))
)

ggplot(probability_table, aes(x = group_size, y = shared_birthday_prob)) +
  geom_line() +
  geom_point() +
  labs(
    title = "Estimated probability of â‰¥1 shared birthday vs. group size",
    x = "Group size",
    y = "Probability of a shared birthday"
  )
```
The probability of a shared birthday between at least two people increases quickly as the group size increases. In very small groups, such as `r prob_tbl$group_size[1]` people, the chance of a match is only about `r round(prob_tbl$shared_birthday_prob[1], 4)`. When the group size reaches `r prob_tbl$group_size[prob_tbl$shared_birthday_prob > 0.5][1]` people, the estimated probability crosses 0.5. By the time the group includes `r prob_tbl$group_size[prob_tbl$shared_birthday_prob > 0.9][1]` people, the probability exceeds 90%, and with `r tail(prob_tbl$group_size, 1)` individuals it approaches `r round(tail(prob_tbl$shared_birthday_prob, 1), 4)`, a shared birthday becomes quite likely.

# Problem 2

### When designing an experiment or analysis, a common question is whether it is likely that a true effect will be detected â€“ put differently, whether a false null hypothesis will be rejected. The probability that a false null hypothesis is rejected is referred to as power, and it depends on several factors, including: the sample size; the effect size; and the error variance. In this problem, you will conduct a simulation to explore power in a one-sample t-test.

```{r}
# Function to generate random samples and extract mean and p-value
simulate_mean_pval <- function(n = 30, mean_true = 0, sd_true = 5, mu_null = 0) {
  data_tbl <- tibble(values = rnorm(n, mean = mean_true, sd = sd_true))
  results <- data_tbl %>% 
    summarize(
      sample_mean = mean(values),
      p_value = tidy(t.test(values, mu = mu_null))$p.value |> round(3)
    )
  return(results)
}

n_iter <- 5000
mean_grid <- 0:6 # mu = 0,1,2,3,4,5,6

# Run simulation for each true mean
sim_results_list <- map(mean_grid, function(mu_val) {
  tibble(iter = 1:n_iter) %>% 
    mutate(res = map(iter, ~simulate_mean_pval(n = 30, mean_true = mu_val, sd_true = 5, mu_null = 0))) %>% 
    unnest(res)
})

# Assign names to list elements for clarity
names(sim_results_list) <- paste0("mu_", mean_grid)

# Combine simulations into a single data
all_results <- map2_dfr(sim_results_list, mean_grid, ~mutate(.x, true_mu = .y))
```

```{r}

```





